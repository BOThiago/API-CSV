"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fsToProject_1 = require("./fsToProject");
var projectToFs_1 = require("./projectToFs");
var path = require("path");
var yaml_1 = require("./yaml");
var chalk = require("chalk");
var fs_1 = require("../fs");
var lodash_1 = require("lodash");
var yamlParser = require("yaml-ast-parser");
var yaml = require("js-yaml");
var debug = require('debug')('project-definition');
var ProjectDefinitionClass = (function () {
    function ProjectDefinitionClass(out, config) {
        this.out = out;
        this.config = config;
    }
    ProjectDefinitionClass.sanitizeDefinition = function (definition) {
        var modules = definition.modules.map(function (module) {
            var name = module.name, files = module.files;
            var content = module.content;
            if (module.definition && typeof module.definition === 'object') {
                // parse + stringify trims away `undefined` values, which are not accepted by the yaml parser
                content = yaml.safeDump(JSON.parse(JSON.stringify(module.definition)));
            }
            return { name: name, content: content, files: files };
        });
        return { modules: modules };
    };
    ProjectDefinitionClass.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, definitionJsonPath;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.config.definitionPath && fs_1.default.pathExistsSync(this.config.definitionPath))) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, fsToProject_1.fsToProject(this.config.definitionDir, this.out)];
                    case 1:
                        _a.definition = _b.sent();
                        if (process.env.GRAPHCOOL_DUMP_LOADED_DEFINITION) {
                            definitionJsonPath = path.join(this.config.definitionDir, 'loaded-definition.json');
                            fs_1.default.writeFileSync(definitionJsonPath, JSON.stringify(this.definition, null, 2));
                        }
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    ProjectDefinitionClass.prototype.save = function (files, silent) {
        return __awaiter(this, void 0, void 0, function () {
            var definitionJsonPath;
            return __generator(this, function (_a) {
                projectToFs_1.projectToFs(this.definition, this.config.definitionDir, this.out, files, silent);
                if (process.env.GRAPHCOOL_DUMP_SAVED_DEFINITION) {
                    definitionJsonPath = path.join(this.config.definitionDir, 'definition.json');
                    fs_1.default.writeFileSync(definitionJsonPath, JSON.stringify(this.definition, null, 2));
                }
                return [2 /*return*/];
            });
        });
    };
    ProjectDefinitionClass.prototype.saveTypes = function () {
        return __awaiter(this, void 0, void 0, function () {
            var definition, types;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, yaml_1.readDefinition(this.definition.modules[0].content, this.out, 'root')];
                    case 1:
                        definition = _a.sent();
                        types = this.definition.modules[0].files[definition.types];
                        this.out.log(chalk.blue("Written " + definition.types));
                        fs_1.default.writeFileSync(path.join(this.config.definitionDir, definition.types), types);
                        return [2 /*return*/];
                }
            });
        });
    };
    ProjectDefinitionClass.prototype.injectEnvironment = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.definition) return [3 /*break*/, 2];
                        _a = this.definition;
                        return [4 /*yield*/, Promise.all(this.definition.modules.map(function (module) { return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                var moduleName, ymlDefinitinon;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            moduleName = module.name && module.name.length > 0 ? module.name : 'root';
                                            return [4 /*yield*/, yaml_1.readDefinition(module.content, this.out, moduleName)];
                                        case 1:
                                            ymlDefinitinon = _a.sent();
                                            if (ymlDefinitinon.functions) {
                                                Object.keys(ymlDefinitinon.functions).forEach(function (fnName) {
                                                    var fn = ymlDefinitinon.functions[fnName];
                                                    if (fn.handler.code) {
                                                        var newFile = module.files[fn.handler.code.src];
                                                        if (fn.handler.code.environment) {
                                                            var file = module.files[fn.handler.code.src];
                                                            newFile = _this.injectEnvironmentToFile(file, fn.handler.code.environment);
                                                        }
                                                        newFile = "'use latest'\n" + newFile;
                                                        module.files[fn.handler.code.src] = newFile;
                                                    }
                                                    ymlDefinitinon.functions[fnName] = fn;
                                                });
                                            }
                                            return [2 /*return*/, module];
                                    }
                                });
                            }); }))];
                    case 1:
                        _a.modules = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    ProjectDefinitionClass.prototype.insertModule = function (moduleName, relativePath) {
        var file = this.definition.modules[0].content;
        var insertion = "\n  " + moduleName + ": " + relativePath;
        return this.insertToDefinition(file, 'modules', insertion);
    };
    ProjectDefinitionClass.prototype.set = function (definition) {
        this.definition = definition;
    };
    ProjectDefinitionClass.prototype.getFunctionAndModule = function (name) {
        if (this.definition && this.definition.modules) {
            var functions = lodash_1.flatMap(this.definition.modules, function (m) {
                return m.definition && m.definition.functions
                    ? m.definition.functions
                    : [];
            });
            var module_1 = this.definition.modules.find(function (m) {
                return (m.definition &&
                    m.definition.functions &&
                    Object.keys(m.definition.functions).includes(name)) ||
                    false;
            });
            if (module_1) {
                return {
                    module: module_1,
                    fn: module_1.definition.functions[name],
                };
            }
        }
        return null;
    };
    ProjectDefinitionClass.prototype.injectEnvironmentToFile = function (file, environment) {
        // get first function line
        var lines = file.split('\n');
        Object.keys(environment).forEach(function (key) {
            var envVar = environment[key];
            lines.splice(0, 0, "process.env['" + key + "'] = '" + envVar + "';");
        });
        return lines.join('\n');
    };
    ProjectDefinitionClass.prototype.insertToDefinition = function (file, key, insertion) {
        var obj = yamlParser.safeLoad(file);
        var modulesMapping = obj.mappings.find(function (m) { return m.key.value === key; });
        var end = modulesMapping.endPosition;
        var newFile = file.slice(0, end) + insertion + file.slice(end);
        var valueStart = modulesMapping.value.startPosition;
        var valueEnd = modulesMapping.value.endPosition;
        if (modulesMapping.value && valueEnd - valueStart < 4) {
            return newFile.slice(0, valueStart) + newFile.slice(valueEnd);
        }
        return file;
    };
    return ProjectDefinitionClass;
}());
exports.ProjectDefinitionClass = ProjectDefinitionClass;
//# sourceMappingURL=ProjectDefinition.js.map
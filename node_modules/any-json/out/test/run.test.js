"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const chai = require("chai");
const assert = chai.assert;
const run_1 = require("../lib/run");
const anyjson = require("../lib");
const fs = require("fs");
const path = require("path");
function args(s) {
    return ['node_path', 'file_path'].concat(s ? s.split(' ') : []);
}
suite("Command Line Application", () => {
    test("help", () => __awaiter(this, void 0, void 0, function* () {
        function testIsHelpMessage(s) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield run_1.main(args(s));
                assert.match(result, /^usage:.*/);
            });
        }
        yield testIsHelpMessage();
        yield testIsHelpMessage("-?");
        yield testIsHelpMessage("--help");
    }));
    test("version", () => __awaiter(this, void 0, void 0, function* () {
        function testIsHelpMessage(s) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield run_1.main(args(s));
                assert.match(result, /^any-json version \d*\.\d*\.\d*/);
            });
        }
        yield testIsHelpMessage("--version");
    }));
    test(".yml files are yaml", () => __awaiter(this, void 0, void 0, function* () {
        const result = yield run_1.main(args("convert .travis.yml"));
        assert.notEqual(result, "");
    }));
    const basicJsonFile = path.join(__dirname, 'fixtures', 'in', 'product-set.json');
    suite("legacy argument format", () => {
        test("opt is not supported", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args("whatever -opt whatever"));
            assert.match(result, /The "opt" argument is no longer supported./);
        }));
        test("j is for JSON", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(`-j ${basicJsonFile} ignored`));
            assert.strictEqual(result, fs.readFileSync(path.join(__dirname, 'fixtures', 'out', 'product-set.json'), 'utf8'));
        }));
        test("c is for [JSON] Compact", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(`${basicJsonFile} -c ignored`));
            assert.strictEqual(result, JSON.stringify(JSON.parse(fs.readFileSync(path.join(__dirname, 'fixtures', 'out', 'product-set.json'), 'utf8'))));
        }));
        test("h is for Hjson", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(`${basicJsonFile} ignored -h`));
            assert.strictEqual(result, fs.readFileSync(path.join(__dirname, 'fixtures', 'out', 'product-set.hjson'), 'utf8'));
        }));
        test("format is for input format", () => __awaiter(this, void 0, void 0, function* () {
            const file = path.join(__dirname, 'fixtures', 'out', 'product-set.ini');
            const result = yield run_1.main(args(`-format=ini ${file}`));
            assert.strictEqual(result, fs.readFileSync(path.join(__dirname, 'fixtures', 'in', `product-set.ini.json`), 'utf8'));
        }));
        test("reading from stdin", () => __awaiter(this, void 0, void 0, function* () {
            require('mock-stdin').stdin();
            const resultPromise = run_1.main(args(`-format=hjson`));
            const mockStdin = process.stdin;
            mockStdin.send("{key:1}");
            mockStdin.send(null);
            assert.strictEqual(yield resultPromise, '{\n    "key": 1\n}');
        }));
        test("reading from stdin requires format argument", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(``));
            assert.match(result, /^usage:.*/);
        }));
    });
    suite("convert", () => {
        test("too many args", () => __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield run_1.main(args("This is a test"));
                assert.fail();
            }
            catch (error) {
                assert.strictEqual(error, "too many arguments");
            }
        }));
        test("explicit convert command", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(`convert ${basicJsonFile}`));
            assert.deepEqual(JSON.parse(result), JSON.parse(fs.readFileSync(basicJsonFile, 'utf8')));
        }));
        test("reading JSON", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(basicJsonFile));
            assert.deepEqual(JSON.parse(result), JSON.parse(fs.readFileSync(basicJsonFile, 'utf8')));
        }));
        test("reading JSON as YAML", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(basicJsonFile + " --input-format=yaml"));
            assert.deepEqual(JSON.parse(result), JSON.parse(fs.readFileSync(basicJsonFile, 'utf8')));
        }));
        test("output as YAML", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(basicJsonFile + " --output-format=yaml"));
            assert.strictEqual(result, fs.readFileSync(path.join(__dirname, 'fixtures', 'out', 'product-set.yaml'), 'utf8'));
        }));
        test("output to file", () => __awaiter(this, void 0, void 0, function* () {
            const outputFile = path.join("out", "test.cson");
            const result = yield run_1.main(args(`${basicJsonFile} ${outputFile}`));
            assert.strictEqual(result, "");
            const written = fs.readFileSync(outputFile, 'utf8');
            assert.strictEqual(written, fs.readFileSync(path.join(__dirname, 'fixtures', 'out', 'product-set.cson'), 'utf8'));
        }));
    });
    suite("combine", () => {
        test("to standard out", () => __awaiter(this, void 0, void 0, function* () {
            const result = yield run_1.main(args(`combine ${basicJsonFile} ${basicJsonFile}`));
            const singleEntry = JSON.parse(fs.readFileSync(basicJsonFile, 'utf8'));
            assert.deepEqual(JSON.parse(result), [singleEntry, singleEntry]);
        }));
        test("to file", () => __awaiter(this, void 0, void 0, function* () {
            const outputFile = 'out/test.yaml';
            const result = yield run_1.main(args(`combine ${basicJsonFile} ${basicJsonFile} --out=${outputFile}`));
            assert.strictEqual(result, "");
            const written = fs.readFileSync(outputFile, 'utf8');
            const singleEntry = JSON.parse(fs.readFileSync(basicJsonFile, 'utf8'));
            assert.deepEqual(yield anyjson.decode(written, 'yaml'), [singleEntry, singleEntry]);
        }));
    });
    suite("split", () => {
        test("too few arguments", () => __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield run_1.main(args("split file.csv"));
                assert.fail();
            }
            catch (error) {
                assert.strictEqual(error, "too few arguments");
            }
        }));
        test("not an array", () => __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield run_1.main(args(`split package.json used-parameter`));
                assert.fail();
            }
            catch (error) {
                assert.strictEqual(error, "split only works on arrays");
            }
        }));
        test("can split flat csv", () => __awaiter(this, void 0, void 0, function* () {
            const file = path.join(__dirname, 'fixtures', 'out', 'product-set.csv');
            const result = yield run_1.main(args(`split ${file} out/{id}.json`));
            assert.strictEqual(result, `out/2.json written
out/3.json written`);
        }));
    });
});

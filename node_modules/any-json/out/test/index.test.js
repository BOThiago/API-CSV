"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const anyjson = require("../lib");
const fs = require("fs");
const promisify = require("util.promisify");
const readFile = promisify(fs.readFile);
const path = require("path");
const chai = require("chai");
const assert = chai.assert;
const fixturesDirectory = path.join(__dirname, 'fixtures');
function inputFixture(name) {
    return path.join(fixturesDirectory, 'in', name);
}
function outputFixture(name) {
    return path.join(fixturesDirectory, 'out', name);
}
function readInputFixture(name) {
    return readFile(inputFixture(name), 'utf8');
}
function readOutputFixture(name, encoding = 'utf8') {
    return readFile(outputFixture(name), encoding);
}
suite('safe-formats', () => {
    const safe_formats = [
        "cson",
        "hjson",
        "json",
        "json5",
        "yaml"
    ];
    testEncode(safe_formats);
    testDecode(safe_formats);
});
suite('problematic-formats', () => {
    const problematic_formats = [
        "ini",
    ];
    testEncode(problematic_formats.concat(["xml"]));
    testDecode(problematic_formats);
    // TOML does not support top-level arrays.
    suite('toml', () => {
        test('encode', () => __awaiter(this, void 0, void 0, function* () {
            const format = "toml";
            const input = JSON.parse(yield readInputFixture('product.json'));
            const actual = anyjson.encode(input, format);
            const expected = readOutputFixture(`product.${format}`);
            return assert.strictEqual(yield actual, yield expected);
        }));
        test('decode', () => __awaiter(this, void 0, void 0, function* () {
            const format = "toml";
            const expected = JSON.parse(yield readInputFixture('product.json'));
            const contents = yield readOutputFixture('product.' + format);
            const actual = yield anyjson.decode(contents, format);
            return assert.deepEqual(actual, expected);
        }));
    });
});
suite('tabular-formats', () => {
    const tabular_formats = ["csv"];
    testEncode(tabular_formats);
    testDecode(tabular_formats);
});
suite('multi-sheet workbooks', () => {
    const multisheet_formats = [
        "xls",
        "xlsx"
    ];
    testDecode(multisheet_formats);
    for (const format of multisheet_formats) {
        test(`decode ${format}`, () => __awaiter(this, void 0, void 0, function* () {
            const expected = JSON.parse(yield readInputFixture(`multi-sheet-workbook.json`));
            const contents = yield readOutputFixture(`multi-sheet-workbook.${format}`, anyjson.getEncoding(format));
            const actual = yield anyjson.decode(contents, format);
            return assert.deepEqual(actual, expected);
        }));
        test(`encode ${format}`, () => __awaiter(this, void 0, void 0, function* () {
            const input = JSON.parse(yield readInputFixture(`multi-sheet-workbook.json`));
            const actual = yield anyjson.encode(input, format);
            const expected = yield readOutputFixture(`multi-sheet-workbook.${format}`, anyjson.getEncoding(format));
            return assert.deepEqual(yield anyjson.decode(actual, format), yield anyjson.decode(expected, format));
        }));
    }
});
function testEncode(formats) {
    suite('encode', function () {
        suite('product-set', () => {
            for (const format of formats) {
                test(format, function () {
                    return __awaiter(this, void 0, void 0, function* () {
                        const input = JSON.parse(yield readInputFixture('product-set.json'));
                        const actual = anyjson.encode(input, format);
                        const expected = readOutputFixture(`product-set.${format}`, anyjson.getEncoding(format));
                        return assert.strictEqual(yield actual, yield expected);
                    });
                });
            }
        });
    });
}
;
function testDecode(formats) {
    suite('decode', function () {
        suite('product-set', () => {
            for (const format of formats) {
                test(format, function () {
                    return __awaiter(this, void 0, void 0, function* () {
                        const expected = yield getExpectedJson(format);
                        const contents = yield readOutputFixture('product-set.' + format, anyjson.getEncoding(format));
                        const actual = yield anyjson.decode(contents, format);
                        return assert.deepEqual(actual, expected);
                    });
                });
            }
        });
    });
}
function getExpectedJson(format) {
    return __awaiter(this, void 0, void 0, function* () {
        const specializedPath = inputFixture(`product-set.${format}.json`);
        if (fs.existsSync(specializedPath)) {
            return JSON.parse(yield readFile(specializedPath, 'utf8'));
        }
        else {
            return JSON.parse(yield readInputFixture('product-set.json'));
        }
    });
}

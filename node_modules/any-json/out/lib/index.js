"use strict";
/*! @preserve
 * any-json
 *
 * Copyright 2017 Adam Voss, MIT license
 * Copyright 2015-2016 Christian Zangl, MIT license
 * Details and documentation:
 * https://github.com/laktak/any-json
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cson = require("cson");
const csv = require("fast-csv");
const hjson = require("hjson");
const ini = require("ini");
const json5 = require("json5");
const toml = require("toml-j0.4");
const tomlify = require("tomlify-j0.4");
const util = require("util");
require('util.promisify/shim')();
const strip_json_comments = require("strip-json-comments");
const XLSX = require("xlsx");
const xml2js = require("xml2js");
const yaml = require("js-yaml");
class AbstractWorkbookConverter {
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const book = XLSX.utils.book_new();
            if (Array.isArray(value)) {
                const sheet = XLSX.utils.json_to_sheet(value);
                XLSX.utils.book_append_sheet(book, sheet);
            }
            else {
                for (let sheetName of Object.getOwnPropertyNames(value)) {
                    const sheet = XLSX.utils.json_to_sheet(value[sheetName]);
                    XLSX.utils.book_append_sheet(book, sheet, sheetName);
                }
            }
            return XLSX.write(book, { WTF: true, bookType: this.bookType, type: "binary" });
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            const book = XLSX.read(text, { type: "binary" });
            if (book.SheetNames.length === 1) {
                return XLSX.utils.sheet_to_json(book.Sheets[book.SheetNames[0]], { raw: true, defval: null });
            }
            const result = {};
            for (let sheet of book.SheetNames) {
                result[sheet] = XLSX.utils.sheet_to_json(book.Sheets[sheet], { raw: true, defval: null });
            }
            return result;
        });
    }
}
class CsonConverter {
    constructor() {
        this.name = 'cson';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return cson.stringify(value, undefined, 2);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return cson.parse(text, reviver);
        });
    }
}
class CsvConverter {
    constructor() {
        this.name = 'csv';
    }
    encode(value) {
        return new Promise((resolve, reject) => {
            if (Array.isArray(value)) {
                csv.writeToString(value, { headers: true }, function (err, result) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(result);
                    }
                });
            }
            else {
                reject("CSV encoding requires the object be an array.");
            }
        });
    }
    decode(text, reviver) {
        return new Promise((resolve, reject) => {
            const res = [];
            csv.fromString(text, { headers: true })
                .on("data", function (data) { res.push(data); })
                .on("end", function () { resolve(res); });
        });
    }
}
class HjsonConverter {
    constructor() {
        this.name = 'hjson';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return hjson.stringify(value);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return hjson.parse(text);
        });
    }
}
class IniConverter {
    constructor() {
        this.name = 'ini';
    }
    looksLikeArray(object) {
        const areInts = Object.getOwnPropertyNames(object).every(s => /^\d+$/.test(s));
        if (!areInts) {
            return false;
        }
        const ints = Object.getOwnPropertyNames(object).map(s => parseInt(s)).sort();
        return [...Array(ints.length)].every(i => i === ints[i]);
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return ini.stringify(value);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsed = ini.parse(text);
            if (!this.looksLikeArray(parsed)) {
                return parsed;
            }
            const array = Array(Object.getOwnPropertyNames(parsed).length);
            for (var index = 0; index < array.length; index++) {
                array[index] = parsed[index];
            }
            return array;
        });
    }
}
class JsonConverter {
    constructor() {
        this.name = 'json';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return JSON.stringify(value, null, 4);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return JSON.parse(strip_json_comments(text), reviver);
        });
    }
}
class Json5Converter {
    constructor() {
        this.name = 'json5';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return json5.stringify(value, null, 4);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return json5.parse(text, reviver);
        });
    }
}
class TomlConverter {
    constructor() {
        this.name = 'toml';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return tomlify.toToml(value, undefined);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return toml.parse(text);
        });
    }
}
class XlsxConverter extends AbstractWorkbookConverter {
    constructor() {
        super(...arguments);
        this.name = "xlsx";
        this.bookType = "xlsx";
    }
}
class XlsConverter extends AbstractWorkbookConverter {
    constructor() {
        super(...arguments);
        this.name = "xls";
        this.bookType = "xlml";
    }
}
class XmlConverter {
    constructor() {
        this.name = 'xml';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = new xml2js.Builder();
            return builder.buildObject(value);
        });
    }
    decode(text, reviver) {
        return util.promisify(xml2js.parseString)(text);
    }
}
class YamlConverter {
    constructor() {
        this.name = 'yaml';
    }
    encode(value) {
        return __awaiter(this, void 0, void 0, function* () {
            return yaml.safeDump(value);
        });
    }
    decode(text, reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return yaml.safeLoad(text);
        });
    }
}
const codecs = new Map([
    new CsonConverter(),
    new CsvConverter(),
    new HjsonConverter(),
    new IniConverter(),
    new JsonConverter(),
    new Json5Converter(),
    new TomlConverter(),
    new XlsConverter(),
    new XlsxConverter(),
    new XmlConverter(),
    new YamlConverter()
].map(c => [c.name, c]));
function decode(text, format) {
    return __awaiter(this, void 0, void 0, function* () {
        const codec = codecs.get(format);
        if (codec) {
            return codec.decode(text, undefined);
        }
        throw new Error("Unknown format " + format + "!");
    });
}
exports.decode = decode;
function encode(value, format) {
    return __awaiter(this, void 0, void 0, function* () {
        const codec = codecs.get(format);
        if (codec) {
            return codec.encode(value);
        }
        throw new Error("Unknown format " + format + "!");
    });
}
exports.encode = encode;
/**
 * Gets the anticipated string encoding for the given format.
 */
function getEncoding(format) {
    switch (format) {
        case "xlsx": return "binary";
        case "xls": return "binary";
        default: return "utf8";
    }
}
exports.getEncoding = getEncoding;
